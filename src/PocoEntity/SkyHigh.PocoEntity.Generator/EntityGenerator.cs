using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Scriban;
using SkyHigh.EntitySchemaParser.Entities;
using System;
using System.IO;
using System.Linq;
using System.Text;

namespace SkyHigh.PocoEntity.Generator;

[Generator]
public class EntityGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // JSON deserialize
        var schemas = context.Prepare("entitySchema.json");

        // Generate code based on schema
        context.RegisterSourceOutput(schemas, (spc, schema) =>
        {
            if (schema == null)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "SH0001",
                        "JSON Schema Error",
                        "Error parsing JSON schema",
                        "SkyHigh",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None));
                return;
            }

            foreach (var entity in schema.Interfaces)
            {
                // Entity sınıfı kodunu oluştur
                var sourceCode = GenerateInterface(schema, entity);

                // Oluşturulan kodu ekle
                spc.AddSource($"{entity.Name}.gin.cs", SourceText.From(sourceCode, Encoding.UTF8));
            }

            foreach (var entity in schema.BaseTypes)
            {
                // Entity sınıfı kodunu oluştur
                var sourceCode = GenerateEntityClass(schema, entity);

                // Oluşturulan kodu ekle
                spc.AddSource($"{entity.Name}.gen.cs", SourceText.From(sourceCode, Encoding.UTF8));
            }

            foreach (var entity in schema.Entities)
            {
                // Entity sınıfı kodunu oluştur
                var sourceCode = GenerateEntityClass(schema, entity);

                // Oluşturulan kodu ekle
                spc.AddSource($"{entity.Name}.gen.cs", SourceText.From(sourceCode, Encoding.UTF8));
            }

            foreach (var @enum in schema.Enums)
            {
                // Entity sınıfı kodunu oluştur
                var sourceCode = GenerateEnum(schema, @enum);

                // Oluşturulan kodu ekle
                spc.AddSource($"{@enum.Name}.geu.cs", SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }

    private const string DEFAULT_FILE_HEADER = @"
{{~
    current_date = date.now | date.to_string '%Y-%m-%d %H:%M:%S'
~}}
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by {{ generator_name }} version {{ generator_version }}
//     Template version: {{ template_version }}
//
//     Generated at: {{ current_date }}
//     Based on model: {{ model_name }} [{{ model_version }}]
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
        
";
    private const string GENERATOR_NAME = "SkyHigh.PocoEntity.Generator";
    private const string GENERATOR_VERSION = "1.0.0";
    private const string TEMPLATE_VERSION = "1.0.0";

    private string GenerateInterface(EntitySchema schema, InterfaceDefinition interfaceDefinition)
    {
        const string template = """
{{~ func writeInterfaceSummary(summary) ~}}
    {{~ if summary && summary.size > 0 ~}}
    /// <summary>
    /// {{ summary }}
    /// </summary>
    {{~ end ~}}
{{~ end ~}}
{{~ func writeInterfaceFirstRow(entity) ~}}
    public{{
    if entity.is_partial
        " partial"
    end
}} interface {{ entity.name }}
    {{- if entity.type_parameters.size > 0 -}}
<
    {{- entity.type_parameters | array.join ", " -}}
>
    {{- end }}
    {{~ if entity.interfaces.size > 0 ~}}
        : {{ entity.interfaces | array.join ", " }}
    {{~ end ~}}
    {{~ for i in entity.type_filters ~}}
        where {{ i.key }}: {{ i.value }}
    {{~ end ~}}
{{~ end ~}}
{{~ func writeProperty(property) ~}}
    {{~ if property.summary && property.summary.size > 0 ~}}
        /// <summary>
        /// {{ property.summary }}
        /// </summary>
    {{~ end ~}}
        {{ property.type }} {{ property.name }} { get; set; }
{{~ end ~}}
{{~ func writeRelation(relationship) ~}}
        // {{ relationship.name }}
    {{~ if relationship.summary && relationship.summary.size > 0 ~}}
        /// <summary>
        /// {{ relationship.summary }}
        /// </summary>
    {{~ end ~}}
    {{~ if relationship.is_collection ~}}
        List<{{ relationship.entity_type }}> {{ relationship.name }} { get; set; } = new List<{{ relationship.entity_type }}>();
    {{~ else ~}}
        {{ relationship.entity_type }} {{ relationship.name }} { get; set; }
    {{~ end ~}}
{{~ end ~}}
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

namespace {{ namespace }}
{
    {{~ writeInterfaceSummary(entity.summary) ~}}
    {{~ writeInterfaceFirstRow(entity) ~}}
    {
        {{~ for property in entity.properties ~}}
            {{~ if for.index > 0 ~}}

            {{~ end ~}}
            {{~ writeProperty(property) ~}}
        {{~ end ~}}
        {{~ if entity.relationships.size > 0 ~}}

        // Relationships
            {{~ for relationship in entity.relationships ~}}
                {{~ if for.index > 0 ~}}

                {{~ end ~}}
                {{~ writeRelation(relationship) ~}}
            {{~ end ~}}
        {{~ end ~}}
    }
}
""";
        var scribanTemplate = Template.Parse(DEFAULT_FILE_HEADER + template);
        return scribanTemplate.Render(new
        {
            GeneratorName = GENERATOR_NAME,
            GeneratorVersion = GENERATOR_VERSION,
            TemplateVersion = TEMPLATE_VERSION,
            ModelName = schema.Name,
            ModelVersion = schema.Version,
            Schema = schema,
            Entity = interfaceDefinition,
            Namespace = GetNamespace(schema.BaseNamespace, interfaceDefinition.Namespace)
        });
    }

    private string GenerateEntityClass(EntitySchema schema, ClassDefinition classDefinition)
    {
        const string template = """
{{~ func writeClassSummary(summary) ~}}
    {{~ if summary && summary.size > 0 ~}}
    /// <summary>
    /// {{ summary }}
    /// </summary>
    {{~ end ~}}
{{~ end ~}}
{{~ func writeClassFirstRow(entity) ~}}
{{~ 
  # Boş bir array oluştur
  inheritance_list = []

  # Eğer base_type dolu ise, array'e ekle
  if entity.base_type != null && entity.base_type != "" 
    inheritance_list = inheritance_list | array.add entity.base_type
  end

  # Eğer interfaces array'i varsa ve boş değilse, bunları inheritance_list'e ekle
  if entity.interfaces != null && entity.interfaces.size > 0
    for interface in entity.interfaces
      inheritance_list = inheritance_list | array.add interface
    end
  end

  # inheritance_list artık hem base_type (varsa) hem de interfaces'leri içeriyor
~}}
    public{{
    if entity.is_abstract
        " abstract"
    else if entity.is_sealed
        " sealed"
    end
}}{{
    if entity.is_partial
        " partial"
    end
}} class {{ entity.name }}
{{- if entity.type_parameters.size > 0 -}}
<
{{- entity.type_parameters | array.join ", " -}}
>
{{- end }}
    {{~ if inheritance_list.size > 0 ~}}
        {{~ for i in inheritance_list ~}}
        {{ if for.index == 0 }}:{{ else }},{{ end }} {{ i }}
        {{~ end ~}}
    {{~ end ~}}
    {{~ for i in entity.type_filters ~}}
        where {{ i.key }}: {{ i.value }}
    {{~ end ~}}
{{~ end ~}}
{{~ func writeProperty(property) ~}}
    {{~ if property.summary && property.summary.size > 0 ~}}
        /// <summary>
        /// {{ property.summary }}
        /// </summary>
    {{~ end ~}}
    {{~ if property.is_required ~}}
        [Required]
    {{~ end ~}}
    {{~ if property.max_length ~}}
        [MaxLength({{ property.max_length }})]
    {{~ end ~}}
    {{~ if property.default_value ~}}
        [DefaultValue({{ property.default_value }})]
    {{~ end ~}}
        public {{ if property.is_required }}required {{ end }}{{ property.type }} {{ property.name }} { get; set; }
    {{- if property.default_value -}}
        {{ " " }}= {{ property.default_value }};
    {{- end }}
{{~ end ~}}
{{~ func writeRelation(relation) ~}}
        // {{ relationship.name }}
    {{~ if relationship.summary && relationship.summary.size > 0 ~}}
        /// <summary>
        /// {{ relationship.summary }}
        /// </summary>
    {{~ end ~}}
    {{~ if relationship.is_collection ~}}
        public List<{{ relationship.entity_type }}> {{ relationship.name }} { get; set; } = new List<{{ relationship.entity_type }}>();
    {{~ else ~}}
        public {{ relationship.entity_type }} {{ relationship.name }} { get; set; }
    {{~ end ~}}
{{~ end ~}}
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

namespace {{ namespace }}
{
    {{~ writeClassSummary(entity.summary) ~}}
    {{~ writeClassFirstRow(entity) ~}}
    {
    {{~ for property in entity.properties ~}}
        {{~ if for.index > 0 ~}}

        {{~ end ~}}
        {{~ writeProperty(property) ~}}
    {{~ end ~}}
    {{~ if entity.relationships.size > 0 ~}}

        // Relationships
        {{~ for relationship in entity.relationships ~}}
            {{~ if for.index > 0 ~}}

            {{~ end ~}}
            {{~ writeRelation(relationship) ~}}
        {{~ end ~}}
    {{~ end ~}}
    }
}
""";
        var scribanTemplate = Template.Parse(DEFAULT_FILE_HEADER + template);
        return scribanTemplate.Render(new
        {
            GeneratorName = GENERATOR_NAME,
            GeneratorVersion = GENERATOR_VERSION,
            TemplateVersion = TEMPLATE_VERSION,
            ModelName = schema.Name,
            ModelVersion = schema.Version,
            Schema = schema,
            Entity = classDefinition,
            Namespace = GetNamespace(schema.BaseNamespace, classDefinition.Namespace)
        });
    }

    private string GenerateEnum(EntitySchema schema, EnumDefinition enumDefinition)
    {
        const string template = """
using System;

namespace {{ namespace }}
{
    public enum {{ enum.name }}{{ if enum_type != "" }} : {{ enum_type }}{{ end }}
    {
        {{~ for value in enum.values ~}}
        {{ value.key }} = {{ value.value }},
        {{~ end ~}}
    }
}
""";
        var enumType = enumDefinition.BaseType switch
        {
            EnumBaseType.Byte => "byte",
            EnumBaseType.Int => "",
            EnumBaseType.Long => "long",
            EnumBaseType.Short => "short",
            EnumBaseType.SByte => "sbyte",
            EnumBaseType.UInt => "uint",
            EnumBaseType.ULong => "ulong",
            EnumBaseType.UShort => "ushort",
            EnumBaseType.String => "string",
            _ => throw new InvalidOperationException("Invalid enum base type.")
        };

        var scribanTemplate = Template.Parse(DEFAULT_FILE_HEADER + template);
        return scribanTemplate.Render(new
        {
            GeneratorName = GENERATOR_NAME,
            GeneratorVersion = GENERATOR_VERSION,
            TemplateVersion = TEMPLATE_VERSION,
            ModelName = schema.Name,
            ModelVersion = schema.Version,
            Schema = schema,
            Enum = enumDefinition,
            EnumType = enumType,
            Namespace = GetNamespace(schema.BaseNamespace, enumDefinition.Namespace)
        });
    }

    private static string GetNamespace(string baseNamespace, string @namespace)
    {
        if (@namespace == ".")
        {
            return baseNamespace;
        }
        if (@namespace.StartsWith("."))
        {
            return $"{baseNamespace}{@namespace}";
        }
        return @namespace;
    }
}